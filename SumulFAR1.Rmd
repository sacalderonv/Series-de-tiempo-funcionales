---
title: "Simular un FAR 1"
output: html_document
date: "2025-10-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Simular un FAR(1)

El siguiente código simula un FAR(1) y es basado en el libro de Introduction to
Functional Data Analysis(Piotr Kokoszka-Matthew Reimherr) de 2017.

Trabajamos en $L^2[0,1]$. Diremos que $\{X_n\}$ (de media cero por simplicidad) sigue un FAR(1) si
$$
X_n=\Phi(X_{n-1})+\varepsilon_n,\qquad \Phi:L^2\to L^2 \text{ acotado,}
$$
típicamente integral: $$\Phi(x)(t)=\int \varphi(t,s)x(s)\,ds$$. 

Su versión puntual:
$$
X_n(t)=\int \varphi(t,s)X_{n-1}(s)\,ds+\varepsilon_n(t).
$$

Para este caso vamos a asumir que 
$$\varphi(t,s)=\alpha st$$
con $\alpha=9/4$ tal que 
$$\|  \Phi \|=\left\{ \int\int \varphi^2(t,s) dtds\right\}^{1/2}=3/4.$$

Además asimimos que el proceso de ruido fucnional sigue la siguiente forma:
$$\epsilon_n(t)=Z_{n1}\sin(\pi t)+\frac{1}{2}Z_{n2}\cos(2\pi t), \ t\in[0,1],$$
donde $Z_{1n}$ y $Z_{2n}$ son V.A independientes normales estándar.
```{r Iniciales}
library(fda)
	
	m <- 100 ##número de puntos discretizados en cada tiempo t
	burnin <- 50 # Primeras 50 fucniones son de calentamiento
	N <- 200 #Total de curvas s simular 
	N1 <- N + burnin # 
	alpha <- 9/4

```

Ahora se crean dos matrices para guardar los ruidos y los valores del proceso funcional. Cada columna almacenará los 100 puntos discretizados de cada curva. Se incializa el primer ruido.

```{r matrices}
X <- matrix(0, m+1, N1)
epsilon <- matrix(0, m+1, N1)
epsilon[,1] <- rnorm(1)*sin(pi*(0:m/m)) + 0.5*rnorm(1)*cos(2*pi*(0:m/m))
```

Ahora se crean un ciclo para ir simulando el proceso de ruido y el proceso funcional. También se remueve la parte del calentamiento.


```{r ciclo simulacion}
for(i in 2:N1){
		epsilon[,i] <- rnorm(1)*sin(pi*(0:m/m)) + 0.5*rnorm(1)*cos(2*pi*(0:m/m))
		X[,i] <- alpha*(1/m)^2*sum((1:m)*X[2:(m+1), i-1])*(0:m/m) + epsilon[,i]
	}
	X <- X[, -(1:burnin)]

```

Se grafican los últimos 10 puntos temporales discretizado sin suavizado

```{r ultimos 10 sin suavizado}
last=10
plot.ts(c(X[,(N-last+1):N]),ylim=c(min(X[,(N-last):N])-0.5,0.5+max(X[,(N-last):N])),axes=F,xlab="",ylab="",lwd=2)
axis(2); axis(1,tick=F,labels=F); abline(h=0)
abline(v=seq(0,last*(m+1),by=m+1), lty=2); box()
```

Ahora se suavizan los putos discretizados usando splines

```{r}
basisfd=10 # number of basis functions to represent each functional observation
basis=create.bspline.basis(c(0,1),nbasis=basisfd,norder=4)
fdX=Data2fd(argvals=0:m/m,X, basis)
fdX
```

Ahora procedemos a hacer componentes principales funcionales para nuestras curvas de series de tiempo

```{r PCA}
p=4 # number of EFPC's
fdXpca=pca.fd(fdX, nharm=p)
eigenvalues=fdXpca$values; scoresX=fdXpca$scores
# jth column of scoresX contains scores of the jth EFPC
harmonicsX=fdXpca$harmonics # extract the EFPC's
varianceprop=fdXpca$varprop #proportion of variance explained by the EFP's
round(varianceprop*100,0)
```
Ahora porcedemos a estimar la superficie $$\varphi(t,s)=\alpha st$$. viendo que tres componentes principales son suficientes.

```{r estimación de la superficie}

phi=9/4*(0:m/m)%*%t(0:m/m)
# True surface evaluated on a discrete bivariate grid
par(mar=c(1.5, 1.5, 3.5, 0.2), mfrow=c(2,2), oma = c(4, 4, 0.2, 0.2))
# 4 panels 2 rows and 2 columns arrangement
axislabelsize=1.5 # controls the size of labels of axes
axisticksize=0.8 # controls the size of ticks of axes
persp((0:m/m),(0:m/m),z=phi,cex.axis = axisticksize,cex.lab=axislabelsize, xlab="t",ylab="s", zlab=" ", theta=30,phi=30,ticktype="detailed", main="True")
# Next we compute hat(phi)
# vivj is the matrix whose entries are products of v_j(s_k)*v_i(t_l)
# Blocks of vivj of m by m matrices represent products of
# v_j(s)v_i(t) evaluated on the (m+1) by (m+1) grid
for(npc in 1:3){
vivj=matrix(0,p*(m+1),p*(m+1))
for(j in 1:npc){
for(i in 1:npc){
vivj[1:(m+1)+(m+1)*(i-1),1:(m+1)+(m+1)*(j-1)]=eval.fd(evalarg=0:m/m, harmonicsX[i])%*%t(eval.fd(evalarg=0:m/m, harmonicsX[j]))
}
}
# phip will be the estimated surface.
phip=matrix(0,m+1,m+1)
for(k in 1:(N-1)){
temp=matrix(0,m+1,m+1)
for(j in 1:npc){
temp1=matrix(0,m+1,m+1)
for(i in 1:npc){
temp1=temp1+scoresX[k+1,i]*vivj[1:(m+1)+(m+1)*(i-1),1:(m+1)+(m+1)*(j-1)]
}
temp=temp+(eigenvalues[j])^(-1)*scoresX[k,j]*temp1
}
phip=phip+temp
}
phip=(1/(N-1))*phip
if (npc==1)
persp((0:m/m),(0:m/m), z=phip, cex.axis =axisticksize, cex.lab=axislabelsize,xlab="t",ylab="s", zlab=" ", theta=30, phi=30, ticktype="detailed", main="p=1")
else if (npc==2)
persp((0:m/m),(0:m/m), z=phip, cex.axis = axisticksize,cex.lab=axislabelsize,xlab="t", ylab="s",zlab=" ",theta=30,phi=30,ticktype="detailed",main="p=2")
else if (npc==3)
persp((0:m/m),(0:m/m), z=phip, cex.axis = axisticksize,cex.lab=axislabelsize,xlab="t", ylab="s", zlab=" ", theta=30, phi=30,ticktype="detailed",main="p=3")
}
```



